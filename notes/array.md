## Variable

variable(변수)는 값을 담는다. 자료형에 따라 해당 메모리에 있는 값을 다르게 해석한다. 예를 들어, `0x7f9b3333`이라는 값이 word에 저장되어 있을 때 자료형이 `long long int`라면 2147483649로, `float`이라면 1.70으로 해석된다. 자료형에 대한 내용은 [type](type.md) 문서를 참고.

하나의 정보(자료)를 담는 변수를 `scalar variable`, 여러 자료를 담을 수 있는 것을 `aggregate variable`이라 한다. 일반적으로 변수는 scalar variable이지만, 배열(array) 또는 구조체(struct)의 경우 aggregate variable이다.

## Array

배열은 같은 자료형을 연속적으로 가지고 있는 변수이다. 각 자료를 원소(element)라고 하며, 원소들을 (인접 원소와 관계없이) 개별적으로 접근/수정할 수 있다. 

일반적으로, 배열의 크기는 고정되어 컴파일 타임에 정해진 크기만큼 (스택 영역에) 메모리를 할당한다. 저자는 매크로 상수를 이용해 배열 크기를 선언하는 것이 괜찮은 컨벤션이라고 소개한다. 

```c
# define LEN 10

int arr[LEN];
```
(참고로, C99 표준에서는 가변길이 배열(Variable-Length Arrays, VLA)을 도입해 런타임에서 변수값에 따라 가변적으로 배열을 위한 메모리를 할당할 수 있도록 만들었다)

## Array Subscription

배열의 각 원소에 접근하는 것을 subscripting 또는 indexing이라고 한다. 대괄호를 이용하여, `{배열의 변수명}[{인덱스}]` 형식으로 원소에 접근할 수 있다. 원소의 index는 0부터 시작한다. 따라서 n크기의 배열 `arr`이 있을 때, 첫 원소는 `arr[0]`, 그 다음 원소는 `arr[1]`, 마지막 원소는 `arr[n-1]`로 접근한다.

이때 subscript된 원소는 *lvalue*이고 배열의 자료형을 가지므로, 다양한 연산에 원소의 값을 직접 사용할 수 있으며 값을 대입해 변경하는 것도 가능하다. 

> 주의할 점은, array subscription시 경계를 확인하지 않는다는 것이다. 

배열의 범위를 벗어난 인덱스를 접근하는 것은 **Undefined Behavior**이고, 다양한 버그/취약점의 원인이 된다. 


## Multidimensional Array

다차원 배열을 선언할 수 있다.
```c
int arr[5][4];
```
위의 코드는 5*4 크기의 2차원 배열을 선언한다. 이렇게 선언한 배열은 행렬과 같은 효과를 가져온다.

## Array Initialization

가장 기본적인 초기화 방법은 중괄호에 원소를 나열하는 방식이다.
```c
int arr[4] = {0, 1, 2, 3};
```
이때 0번 인덱스부터 순서대로 채워지고, ***명시되지 않은 인덱스의 원소들은 자동적으로 0으로 초기화된다***.

C99에 추가된 `designated initializer`는 특정 인덱스의 원소를 지정해서 초기화할 수 있도록 해 준다.
```c
int arr[4] = {[0] = 1, [2] = 3};
```
위 코드의 실행 결과는 `[1, 0, 3, 0]`이다. 명시되지 않은 원소들은 자동적으로 0으로 초기화되기 때문이다.

designated initializer를 사용할때는 주의할 점이 있다. 
> C서운 사실: `int a[] = {1, 2, 3, 4, [0] = 5, 6}`의 결과는 `[5, 6, 3, 4]`이다...

designator를 사용한 인덱스가 기준이 되기 때문에, designated initiailizer와 나열하는 방식을 혼용할 때는 결과가 예상했던 것과 다르게 나타날 수 있다. 


다차원 배열을 초기화할 때는 각각의 row별로 감싸주거나, 전체를 나열해서 초기화할 수 있다.
```c
int arr[3][3] = {
	{0},
	{1, 2, 3},
	{0}
};
```
```c
int arr[3][3] = {
	0, 0, 0,
	1, 2, 3,
	0, 0, 0
};
```
```c
int arr[3][3] = {
	[1][0] = 1, [1][1] = 2, [1][2] = 3
};
```
모두 같은 배열로 초기화한다.

